{
  "id": "jkanime-official-style",
  "name": "JKAnime",
  "version": "1.1.0",
  "author": "Grok",
  "description": "JKAnime.net – Anime en español latino con servidores Filemoon, Streamtape, YourUpload, etc.",
  "type": "streaming",
  "language": "es",
  "payload": "/// <reference path=\"../online-streaming-provider.d.ts\" />\n\nclass Provider {\n    base = \"https://jkanime.net\";\n    api = \"https://jkanime-api.chrismichaelps.workers.dev/api/v1\";\n\n    getSettings() {\n        return {\n            episodeServers: [\"filemoon\", \"streamtape\", \"yourupload\", \"mixdrop\", \"mega\"],\n            supportsDub: false,\n        };\n    }\n\n    async search({ query }) {\n        const res = await fetch(`${this.api}/search?q=${encodeURIComponent(query)}&limit=30`);\n        if (!res.ok) return [];\n        const data = await res.json();\n        return data.animes.map(a => ({\n            id: a.slug,\n            title: a.title,\n            image: a.poster,\n            url: `${this.base}/${a.slug}/`,\n            subOrDub: \"sub\"\n        }));\n    }\n\n    async findEpisodes(id) {\n        const res = await fetch(`${this.api}/anime/${id}`);\n        const data = await res.json();\n        if (!data.episodes || data.episodes.length === 0) return [];\n\n        return data.episodes.map(ep => ({\n            id: ep.number.toString(),\n            number: ep.number,\n            title: `Episodio ${ep.number}`,\n            url: `${this.base}/${id}/${ep.number}/`\n        }));\n    }\n\n    async findEpisodeServer(episode, serverName = \"filemoon\") {\n        // Extraemos slug del anime y número de episodio de la url\n        const match = episode.url.match(/\\/([\\w-]+\\/)(\\d+)\\/$/);\n        if (!match) throw new Error(\"URL de episodio no válida\");\n        const animeSlug = match[1].slice(0, -1);\n        const epNum = match[2];\n\n        const res = await fetch(`${this.api}/servers?anime=${animeSlug}&episode=${epNum}`);\n        const data = await res.json();\n        if (!data.servers) return { videoSources: [] };\n\n        // Buscamos el servidor que queremos (prioridad: filemoon → streamtape → yourupload → etc.)\n        const priority = [\"filemoon\", \"streamtape\", \"yourupload\", \"mixdrop\", \"mega\"];\n        let chosen = null;\n        for (const srv of priority) {\n            chosen = data.servers.find(s => s.server.toLowerCase() === srv);\n            if (chosen) break;\n        }\n        if (!chosen) chosen = data.servers[0]; // fallback al primero que haya\n\n        const videoUrl = chosen.video || chosen.embed || chosen.code;\n\n        return {\n            server: chosen.server.toLowerCase(),\n            headers: {\n                \"Referer\": \"https://jkanime.net/\",\n                \"Origin\": \"https://jkanime.net\"\n            },\n            videoSources: [{\n                url: videoUrl,\n                type: \"mp4\",\n                quality: \"auto\",\n                isM3U8: videoUrl.includes(\".m3u8\")\n            }]\n        };\n    }\n}\n"
}
